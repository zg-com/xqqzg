<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åˆæˆå¤§åˆç…§ â¤ï¸</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { 
            margin: 0; padding: 0; 
            background: linear-gradient(-45deg, #e0eafc, #cfdef3, #f5f7fa, #eef2f3);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            overflow: hidden; 
            font-family: "Microsoft YaHei", sans-serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent;
            height: 100vh;
            height: 100dvh; 
            display: flex; flex-direction: column;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #game-container {
            position: relative; width: 100%; flex: 1;
            display: flex; justify-content: center; align-items: center;
        }

        /* é¡¶éƒ¨ UI */
        .header-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 60px;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; box-sizing: border-box; pointer-events: none; z-index: 10;
        }
        .score-box {
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px);
            padding: 5px 15px; border-radius: 20px; font-weight: bold; color: #57606f; font-size: 18px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05); border: 1px solid rgba(255,255,255,0.8);
        }
        .btn-rank {
            background: #0984e3; color: white; padding: 8px 15px;
            border-radius: 20px; font-size: 14px; pointer-events: auto; cursor: pointer;
            border: none; font-weight: bold; box-shadow: 0 4px 10px rgba(9, 132, 227, 0.3);
            transition: 0.2s;
        }
        .btn-rank:active { transform: scale(0.95); }

        /* åˆ‡æ¢è§’è‰²æŒ‰é’® */
        .btn-switch {
            background: #a29bfe; color: white; padding: 8px 15px;
            border-radius: 20px; font-size: 14px; pointer-events: auto; cursor: pointer;
            border: none; font-weight: bold; box-shadow: 0 4px 10px rgba(162, 155, 254, 0.3);
            margin-right: 10px; transition: 0.2s;
        }
        .btn-switch:active { transform: scale(0.95); }

        /* è¿å‡»ç‰¹æ•ˆ */
        .combo-text {
            position: absolute; top: 25%; left: 50%; transform: translate(-50%, -50%) scale(0);
            font-size: 40px; font-weight: 900; 
            color: #ff9f43; -webkit-text-stroke: 2px #fff;
            text-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none; z-index: 20;
            transition: transform 0.1s; opacity: 0;
        }
        .combo-text.active {
            animation: popCombo 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popCombo {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        /* å¼¹çª—é€šç”¨ */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 99;
            backdrop-filter: blur(3px); display: none; justify-content: center; align-items: center;
        }
        .modal-overlay.show { display: flex; }
        .card {
            background: white; width: 80%; max-width: 320px; padding: 25px; 
            border-radius: 20px; text-align: center; box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            position: relative; animation: slideUp 0.3s ease;
        }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        .role-btn {
            display: block; width: 100%; margin: 10px 0; padding: 15px;
            border: 2px solid #eee; border-radius: 12px; background: white;
            font-size: 18px; font-weight: bold; cursor: pointer; transition: 0.2s;
        }
        .role-btn:active { transform: scale(0.95); background: #f1f2f6; }
        .role-btn.boy { border-color: #74b9ff; color: #0984e3; }
        .role-btn.girl { border-color: #ff7675; color: #d63031; }

        .rank-list {
            list-style: none; padding: 0; text-align: left; max-height: 250px; overflow-y: auto; margin: 10px 0;
        }
        .rank-item {
            display: flex; justify-content: space-between; padding: 12px 5px; border-bottom: 1px dashed #f1f2f6;
            font-size: 15px;
        }
        .rank-close {
            position: absolute; top: 10px; right: 15px; font-size: 24px; cursor: pointer; color: #ccc;
        }
    </style>
</head>
<body>

<div id="app">
    <div id="game-container"></div>

    <div class="header-ui">
        <div class="score-box">å¾—åˆ†: {{ Math.floor(currentScore) }}</div>
        <div>
            <button class="btn-switch" @click="switchRole">ğŸ”„ æ¢äºº</button>
            <button class="btn-rank" @click="openRank">ğŸ† æ’è¡Œ</button>
        </div>
    </div>

    <div class="combo-text" :class="{active: showComboAnim}" :key="comboCount">
        <i>ğŸ”¥</i> è¿å‡» x{{ comboCount }}
    </div>

    <div class="modal-overlay" :class="{show: showRoleSelect}">
        <div class="card">
            <h2>ä½ æ˜¯è°å‘€ï¼ŸğŸ‘€</h2>
            <p style="color:#999; margin-bottom:20px;">é€‰ä¸€æ¬¡å°±å¥½å•¦ï¼Œæ–¹ä¾¿è®°å½•æˆ˜ç»©</p>
            <button class="role-btn boy" @click="selectRole('ğŸ‘¦ å“¥å“¥')">ğŸ‘¦ æˆ‘æ˜¯å“¥å“¥</button>
            <button class="role-btn girl" @click="selectRole('ğŸ‘§ å®è´')">ğŸ‘§ æˆ‘æ˜¯å®è´</button>
        </div>
    </div>

    <div class="modal-overlay" :class="{show: isGameOver}">
        <div class="card">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <p style="font-size: 32px; color:#d63031; font-weight:bold; margin:10px 0;">{{ Math.floor(currentScore) }}</p>
            <p style="color:#666; font-size:14px;">æˆç»©å·²è‡ªåŠ¨ä¸Šä¼ </p>
            <button class="role-btn" style="background:#00b894; color:white; border:none;" @click="restart">å†æ¥ä¸€å±€ ğŸ”¥</button>
            <button class="role-btn" @click="openRank">æŸ¥çœ‹å®¶åº­åœ°ä½ ğŸ‘‘</button>
            <button class="role-btn" style="border:none; color:#999; font-size:14px;" @click="switchRole">åˆ‡æ¢è§’è‰²é‡æ–°å¼€å§‹</button>
        </div>
    </div>

    <div class="modal-overlay" :class="{show: showRank}" @click.self="showRank = false">
        <div class="card">
            <span class="rank-close" @click="showRank = false">Ã—</span>
            <h3>ğŸ‘‘ å®¶åº­å¸ä½æ’è¡Œæ¦œ</h3>
            <ul class="rank-list">
                <li class="rank-item" v-for="(item, index) in rankList" :key="index">
                    <span>
                        <span v-if="index==0">ğŸ¥‡</span>
                        <span v-else-if="index==1">ğŸ¥ˆ</span>
                        <span v-else-if="index==2">ğŸ¥‰</span>
                        <span v-else style="color:#999; width:20px; display:inline-block">{{ index + 1 }}.</span>
                        {{ item.playerName }}
                    </span>
                    <span style="font-weight:bold; color:#57606f">{{ item.score }}</span>
                </li>
            </ul>
        </div>
    </div>
</div>

<script>
    const { createApp, ref, onMounted } = Vue;
    const API_BASE = 'https://darlingweb.onrender.com';
    const { Engine, Render, World, Bodies, Body, Events, Composite } = Matter;

    createApp({
        setup() {
            const currentScore = ref(0);
            const isGameOver = ref(false);
            const showRoleSelect = ref(false);
            const showRank = ref(false);
            const rankList = ref([]);
            const currentPlayer = ref(localStorage.getItem('darling_player_name') || '');
            
            const comboCount = ref(0);
            const showComboAnim = ref(false);
            let lastMergeTime = 0;

            let engine, render;
            let currentBall = null; 
            let isDropping = false;

            // 16ä¸ªç­‰çº§é…ç½®
            const ballTypes = [
                { r: 20, color: '#a29bfe', score: 2 },     
                { r: 28, color: '#74b9ff', score: 4 },     
                { r: 36, color: '#81ecec', score: 8 },     
                { r: 44, color: '#55efc4', score: 16 },    
                { r: 52, color: '#ffeaa7', score: 32 },    
                { r: 60, color: '#fab1a0', score: 64 },    
                { r: 68, color: '#ff7675', score: 128 },   
                { r: 76, color: '#fd79a8', score: 256 },   
                { r: 84, color: '#d63031', score: 512 },   
                { r: 92, color: '#e17055', score: 1024 },  
                { r: 100, color: '#2d3436', score: 2048 }, 
                { r: 108, color: '#f9ca24', score: 4096 }, 
                { r: 116, color: '#686de0', score: 8192 }, 
                { r: 124, color: '#30336b', score: 16384 },
                { r: 132, color: '#badc58', score: 32768 },
                { r: 140, color: '#130f40', score: 65536 } 
            ];

            const createTexture = (r, color, score) => {
                const canvas = document.createElement('canvas');
                const size = r * 2;
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                ctx.beginPath();
                ctx.arc(r, r, r, 0, Math.PI * 2);
                ctx.clip(); 

                ctx.fillStyle = color;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(r - r*0.3, r - r*0.3, r*0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fill();

                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.beginPath();
                ctx.moveTo(0, r);
                ctx.bezierCurveTo(r*0.5, r*0.5, r*1.5, r*1.5, size, r);
                ctx.lineTo(size, size);
                ctx.lineTo(0, size);
                ctx.fill();

                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = `bold ${Math.max(10, r * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(score, r, r);

                return canvas.toDataURL();
            };

            const initGame = () => {
                if (!currentPlayer.value) {
                    showRoleSelect.value = true;
                    return; 
                }

                const container = document.getElementById('game-container');
                container.innerHTML = ''; 
                const width = Math.min(window.innerWidth, 320); // 400px å®½åº¦
                const height = window.innerHeight;

                engine = Engine.create();
                engine.gravity.y = 1.2;  //é‡åŠ›ç³»æ•°ï¼Œä¸‹è½é€Ÿåº¦

                render = Render.create({
                    element: container,
                    engine: engine,
                    options: {
                        width: width,
                        height: height,
                        wireframes: false,
                        background: 'transparent'
                    }
                });

                const ground = Bodies.rectangle(width/2, height, width, 60, { isStatic: true, render: { fillStyle: 'rgba(255,255,255,0.4)' } });
                const leftWall = Bodies.rectangle(0, height/2, 10, height, { isStatic: true, render: { fillStyle: 'rgba(255,255,255,0.2)' } });
                const rightWall = Bodies.rectangle(width, height/2, 10, height, { isStatic: true, render: { fillStyle: 'rgba(255,255,255,0.2)' } });
                const deadLine = Bodies.rectangle(width/2, 300, width, 2, { 
                    isStatic: true, isSensor: true, label: 'DeadLine', render: { fillStyle: 'rgba(235, 77, 75, 0.3)' } 
                });

                World.add(engine.world, [ground, leftWall, rightWall, deadLine]);

                createNewBall(width);

                render.canvas.addEventListener('pointerdown', (e) => {
                    if (isGameOver.value || isDropping) return;
                    if (!currentBall) return;
                    
                    isDropping = true;
                    const x = e.offsetX;
                    const safeX = Math.min(Math.max(x, 25), width - 25);
                    
                    Body.setPosition(currentBall, { x: safeX, y: 50 });
                    Body.setStatic(currentBall, false);
                    Body.setVelocity(currentBall, { x: 0, y: 10 }); 
                    currentBall.label = 'Ball';
                    currentBall = null;

                    setTimeout(() => {
                        createNewBall(width);
                        isDropping = false;
                    }, 300);
                });

                Events.on(engine, 'collisionStart', handleCollision);
                Events.on(engine, 'collisionActive', checkGameOver);

                Engine.run(engine);
                Render.run(render);
            };

            const createNewBall = (width) => {
                let minLevel = 0;
                let maxLevel = 0;

                if (currentScore.value > 10000) { minLevel=1; maxLevel=4; } 
                else if (currentScore.value > 5000) { minLevel=0; maxLevel=3; }
                else if (currentScore.value > 1000) { minLevel=0; maxLevel=2; }
                else { minLevel=0; maxLevel=1; }

                const level = Math.floor(Math.random() * (maxLevel - minLevel + 1)) + minLevel;
                const type = ballTypes[level];
                
                currentBall = Bodies.circle(width / 2, 50, type.r, {
                    isStatic: true,
                    label: 'ReadyBall',
                    render: { 
                        sprite: {
                            texture: createTexture(type.r, type.color, type.score),
                            xScale: 1, yScale: 1
                        }
                    }
                });
                currentBall.level = level;
                World.add(engine.world, currentBall);
            };

            const handleCollision = (event) => {
                const pairs = event.pairs;
                pairs.forEach((pair) => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;

                    if (bodyA.level !== undefined && bodyB.level !== undefined && bodyA.level === bodyB.level) {
                        if (bodyA.id === bodyB.id) return; 

                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;
                        const nextLevel = bodyA.level + 1;

                        if (nextLevel < ballTypes.length) {
                            World.remove(engine.world, [bodyA, bodyB]);
                            
                            const newType = ballTypes[nextLevel];
                            const newBall = Bodies.circle(midX, midY, newType.r, {
                                restitution: 0.5,
                                label: 'Ball',
                                render: { 
                                    sprite: {
                                        texture: createTexture(newType.r, newType.color, newType.score),
                                        xScale: 1, yScale: 1
                                    }
                                }
                            });
                            newBall.level = nextLevel;
                            World.add(engine.world, newBall);

                            if (navigator.vibrate) navigator.vibrate(15); 

                            const now = Date.now();
                            if (now - lastMergeTime < 1500) {
                                comboCount.value++;
                            } else {
                                comboCount.value = 1; 
                            }
                            lastMergeTime = now;

                            if (comboCount.value >= 3) {
                                showComboAnim.value = false;
                                setTimeout(() => showComboAnim.value = true, 10);
                            }

                            const bonus = 1 + (comboCount.value - 1) * 0.1;
                            currentScore.value += (newType.score * bonus);
                        }
                    }
                });
            };

            const checkGameOver = (event) => {
                if(isGameOver.value) return;
                event.pairs.forEach(pair => {
                    if (pair.bodyA.label === 'DeadLine' || pair.bodyB.label === 'DeadLine') {
                        const ball = pair.bodyA.label === 'Ball' ? pair.bodyA : pair.bodyB;
                        if (ball.label === 'Ball' && ball.speed < 0.2 && !isDropping) {
                            triggerGameOver();
                        }
                    }
                });
            };

            const triggerGameOver = () => {
                isGameOver.value = true;
                if(render) render.options.enabled = false;
                submitScore();
            };

            const selectRole = (name) => {
                currentPlayer.value = name;
                localStorage.setItem('darling_player_name', name); 
                showRoleSelect.value = false;
                initGame();
            };

            // ğŸ‘‡ æ–°å¢ï¼šåˆ‡æ¢è§’è‰²é€»è¾‘
            const switchRole = () => {
                if(confirm("ç¡®å®šè¦åˆ‡æ¢è§’è‰²é‡æ–°å¼€å§‹å—ï¼Ÿ")) {
                    localStorage.removeItem('darling_player_name'); // æ¸…é™¤è®°å½•
                    location.reload(); // åˆ·æ–°é¡µé¢
                }
            };

            const submitScore = async () => {
                try {
                    await fetch(`${API_BASE}/game/submit`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            playerName: currentPlayer.value,
                            score: Math.floor(currentScore.value)
                        })
                    });
                } catch(e) { console.error("åˆ†æ•°ä¸Šä¼ å¤±è´¥", e); }
            };

            const openRank = async () => {
                try {
                    const res = await fetch(`${API_BASE}/game/rank`);
                    rankList.value = await res.json();
                    showRank.value = true;
                } catch(e) {}
            };

            const restart = () => {
                location.reload();
            };

            onMounted(() => {
                if (currentPlayer.value) {
                    initGame();
                } else {
                    showRoleSelect.value = true;
                }
            });

            return { 
                currentScore, isGameOver, showRoleSelect, showRank, rankList,
                selectRole, restart, openRank, switchRole, // æš´éœ²ç»™æ¨¡æ¿
                comboCount, showComboAnim 
            };
        }
    }).mount('#app');
</script>
</body>
</html>
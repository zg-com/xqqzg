<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åˆæˆå¤§åˆç…§ â¤ï¸</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background: #ffeaa7; overflow: hidden; font-family: sans-serif; }
        
        #game-container {
            position: relative; width: 100%; height: 100vh;
            display: flex; justify-content: center; align-items: center;
        }

        /* é¡¶éƒ¨ UI */
        .header-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 80px;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; box-sizing: border-box; pointer-events: none; z-index: 10;
        }
        .score-box {
            background: rgba(255,255,255,0.8); padding: 10px 20px;
            border-radius: 20px; font-weight: bold; color: #d63031; font-size: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .btn-rank {
            background: #0984e3; color: white; padding: 10px 15px;
            border-radius: 20px; font-size: 14px; pointer-events: auto; cursor: pointer;
            text-decoration: none; border: none; font-weight: bold;
        }

        /* ç»“æŸå¼¹çª— */
        .game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 99;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            display: none; /* é»˜è®¤éšè— */
        }
        .game-over.show { display: flex; }
        .card {
            background: white; width: 80%; padding: 20px; border-radius: 20px; text-align: center;
        }
        .input-name {
            padding: 10px; font-size: 16px; width: 80%; margin: 10px 0;
            border: 2px solid #eee; border-radius: 8px;
        }
        .btn-submit {
            background: #d63031; color: white; padding: 12px 30px; border: none;
            border-radius: 25px; font-size: 18px; font-weight: bold; cursor: pointer;
        }

        /* æ’è¡Œæ¦œå¼¹çª— */
        .rank-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 90;
            display: none; justify-content: center; align-items: center;
        }
        .rank-modal.show { display: flex; }
        .rank-list {
            list-style: none; padding: 0; text-align: left; max-height: 200px; overflow-y: auto;
        }
        .rank-item {
            display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px dashed #eee;
        }
        .rank-close {
            position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer;
        }
    </style>
</head>
<body>

<div id="app">
    <div id="game-container"></div>

    <div class="header-ui">
        <div class="score-box">å¾—åˆ†: {{ currentScore }}</div>
        <button class="btn-rank" @click="showRank = true">ğŸ† æ’è¡Œæ¦œ</button>
    </div>

    <div class="game-over" :class="{show: isGameOver}">
        <div class="card">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <p style="font-size: 24px; color:#d63031">{{ currentScore }} åˆ†</p>
            <p>æœ¬æ¬¡è¡¨ç°çœŸæ£’ï¼ç•™ä¸‹å¤§åå§ï¼š</p>
            <input class="input-name" v-model="playerName" placeholder="è¾“å…¥åå­— (å¦‚: å®è´)">
            <button class="btn-submit" @click="submitScore">ä¸Šä¼ æˆ˜ç»©</button>
            <button style="margin-top:10px; background:transparent; border:none; color:#999" @click="restart">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <div class="rank-modal" :class="{show: showRank}" @click.self="showRank = false">
        <div class="card" style="position:relative">
            <span class="rank-close" @click="showRank = false">Ã—</span>
            <h3>ğŸ‘‘ å®¶åº­å¸ä½æ’è¡Œæ¦œ</h3>
            <ul class="rank-list">
                <li class="rank-item" v-for="(item, index) in rankList" :key="index">
                    <span>
                        <span v-if="index==0">ğŸ¥‡</span>
                        <span v-else-if="index==1">ğŸ¥ˆ</span>
                        <span v-else-if="index==2">ğŸ¥‰</span>
                        <span v-else>{{ index + 1 }}.</span>
                        {{ item.playerName }}
                    </span>
                    <span style="font-weight:bold; color:#d63031">{{ item.score }}</span>
                </li>
            </ul>
        </div>
    </div>
</div>

<script>
    const { createApp, ref, onMounted } = Vue;
    const API_BASE = 'https://darlingweb.onrender.com';

    // Matter.js æ¨¡å—
    const { Engine, Render, World, Bodies, Body, Events, Composite } = Matter;

    createApp({
        setup() {
            const currentScore = ref(0);
            const isGameOver = ref(false);
            const playerName = ref('å¥³æœ‹å‹'); // é»˜è®¤åå­—
            const showRank = ref(false);
            const rankList = ref([]);

            // æ¸¸æˆé…ç½®
            let engine, render, runner;
            // æ¯ä¸€ä¸ªç­‰çº§çš„çƒçš„é…ç½® (é¢œè‰²å¯ä»¥æ¢æˆå›¾ç‰‡: render: { sprite: { texture: 'img/1.png' } })
            const ballTypes = [
                { r: 20, color: '#ff7979', score: 2 },   // Level 1
                { r: 30, color: '#badc58', score: 4 },   // Level 2
                { r: 40, color: '#f6e58d', score: 8 },   // Level 3
                { r: 50, color: '#ffbe76', score: 16 },  // Level 4
                { r: 60, color: '#e056fd', score: 32 },  // Level 5
                { r: 70, color: '#686de0', score: 64 },  // Level 6
                { r: 80, color: '#30336b', score: 128 }, // Level 7
                { r: 90, color: '#eb4d4b', score: 256 }, // Level 8 (å¤§è¥¿ç“œ)
            ];

            let currentBallType = 0; // å½“å‰é¡¶éƒ¨å‡†å¤‡æ‰è½çš„çƒç±»å‹
            let isDropping = false; // é˜²æ­¢è¿ç‚¹

            const initGame = () => {
                const container = document.getElementById('game-container');
                const width = container.clientWidth > 450 ? 450 : container.clientWidth;
                const height = container.clientHeight;

                // 1. åˆ›å»ºå¼•æ“
                engine = Engine.create();
                
                // 2. åˆ›å»ºæ¸²æŸ“å™¨
                render = Render.create({
                    element: container,
                    engine: engine,
                    options: {
                        width: width,
                        height: height,
                        wireframes: false, // è®¾ä¸º false æ‰èƒ½æ˜¾ç¤ºé¢œè‰²/å›¾ç‰‡
                        background: '#ffeaa7'
                    }
                });

                // 3. åˆ›å»ºè¾¹ç•Œ (å·¦å³å¢™å’Œåº•)
                const ground = Bodies.rectangle(width/2, height, width, 60, { isStatic: true, render: { fillStyle: '#b2bec3' } });
                const leftWall = Bodies.rectangle(0, height/2, 20, height, { isStatic: true, render: { fillStyle: '#b2bec3' } });
                const rightWall = Bodies.rectangle(width, height/2, 20, height, { isStatic: true, render: { fillStyle: '#b2bec3' } });
                // é¡¶éƒ¨çš„â€œæ­»äº¡çº¿â€ä¼ æ„Ÿå™¨
                const deadLine = Bodies.rectangle(width/2, 100, width, 2, { 
                    isStatic: true, isSensor: true, label: 'DeadLine', render: { fillStyle: 'transparent' } 
                });

                World.add(engine.world, [ground, leftWall, rightWall, deadLine]);

                // 4. ç”Ÿæˆé¡¶éƒ¨å¾…å‘½çš„å°çƒ
                createReadyBall(width);

                // 5. ç‚¹å‡»äº‹ä»¶
                render.canvas.addEventListener('click', (e) => {
                    if (isDropping || isGameOver.value) return;
                    isDropping = true;

                    // è·å–é¡¶éƒ¨é‚£ä¸ªå¾…å‘½çš„çƒ
                    const readyBall = engine.world.bodies.find(b => b.label === 'ReadyBall');
                    if (readyBall) {
                        // ç§»åŠ¨åˆ°ç‚¹å‡»çš„æ¨ªåæ ‡ä½ç½®
                        const x = e.offsetX; // è·å–ç›¸å¯¹ç”»å¸ƒçš„ç‚¹å‡»ä½ç½®
                        // é™åˆ¶ä¸è¦å‡ºå¢™
                        const safeX = Math.min(Math.max(x, 30), width - 30);
                        Body.setPosition(readyBall, { x: safeX, y: 50 });
                        
                        // è®©å®ƒå˜ä¸ºåŠ¨æ€ç‰©ä½“ï¼Œå¼€å§‹æ‰è½
                        Body.setStatic(readyBall, false);
                        readyBall.label = 'Ball'; // æ‰ä¸‹å»å°±å˜æˆæ™®é€šçƒäº†
                        
                        // 1ç§’åç”Ÿæˆä¸‹ä¸€ä¸ªå¾…å‘½çƒ
                        setTimeout(() => {
                            createReadyBall(width);
                            isDropping = false;
                        }, 800);
                    }
                });

                // 6. ç¢°æ’æ£€æµ‹ (åˆæˆé€»è¾‘)
                Events.on(engine, 'collisionStart', (event) => {
                    const pairs = event.pairs;
                    pairs.forEach((pair) => {
                        const bodyA = pair.bodyA;
                        const bodyB = pair.bodyB;

                        // å¦‚æœä¸¤ä¸ªçƒç¢°åœ¨ä¸€èµ·ï¼Œä¸”ç­‰çº§ç›¸åŒ
                        if (bodyA.level !== undefined && bodyB.level !== undefined && bodyA.level === bodyB.level) {
                            // ä¸”å®ƒä»¬ä¸æ˜¯åŒä¸€ä¸ªçƒï¼ˆé˜²æ­¢æå…¶ç½•è§çš„bugï¼‰
                            if (bodyA.id === bodyB.id) return;

                            // æ‰¾åˆ°å®ƒä»¬çš„ä¸­ç‚¹
                            const midX = (bodyA.position.x + bodyB.position.x) / 2;
                            const midY = (bodyA.position.y + bodyB.position.y) / 2;
                            const nextLevel = bodyA.level + 1;

                            // å¦‚æœè¿˜æœ‰ä¸‹ä¸€çº§
                            if (nextLevel < ballTypes.length) {
                                // ç§»é™¤æ—§çš„ä¸¤ä¸ªçƒ
                                World.remove(engine.world, [bodyA, bodyB]);
                                
                                // åŠ åˆ†
                                currentScore.value += ballTypes[bodyA.level].score;

                                // ç”Ÿæˆæ–°çƒ
                                const newBall = createBall(midX, midY, nextLevel, false);
                                World.add(engine.world, newBall);
                            }
                        }
                    });
                });

                // 7. æ­»äº¡æ£€æµ‹ (ç®€åŒ–ç‰ˆï¼šå¦‚æœçƒå †å¤ªé«˜ç¢°åˆ°é¡¶çº¿ï¼Œä¸”é€Ÿåº¦å¾ˆæ…¢ï¼Œå°±ç®—è¾“)
                Events.on(engine, 'collisionActive', (event) => {
                    event.pairs.forEach(pair => {
                        // æ£€æŸ¥æ˜¯å¦æœ‰ç‰©ä½“ç¢°åˆ°äº† DeadLine
                        if (pair.bodyA.label === 'DeadLine' || pair.bodyB.label === 'DeadLine') {
                            const ball = pair.bodyA.label === 'Ball' ? pair.bodyA : pair.bodyB;
                            // åªæœ‰å½“çƒåŸºæœ¬é™æ­¢ï¼Œä¸”ä¸æ˜¯åˆšç”Ÿæˆçš„ readyBall æ—¶
                            if (ball.label === 'Ball' && ball.speed < 0.5 && !isDropping) {
                                // æ¸¸æˆç»“æŸ
                                gameOver();
                            }
                        }
                    });
                });

                Engine.run(engine);
                Render.run(render);
            };

            // åˆ›å»ºçƒä½“è¾…åŠ©å‡½æ•°
            const createBall = (x, y, level, isStatic) => {
                const type = ballTypes[level];
                const ball = Bodies.circle(x, y, type.r, {
                    isStatic: isStatic,
                    restitution: 0.3, // å¼¹æ€§
                    label: isStatic ? 'ReadyBall' : 'Ball',
                    render: { fillStyle: type.color } // è¿™é‡Œä»¥åå¯ä»¥åŠ  sprite: { texture: '...' }
                });
                ball.level = level; // ç»‘å®šç­‰çº§
                return ball;
            };

            const createReadyBall = (width) => {
                // éšæœºç”Ÿæˆ 0~2 çº§çš„çƒä½œä¸ºåˆå§‹çƒ
                const level = Math.floor(Math.random() * 3);
                const ball = createBall(width / 2, 50, level, true);
                World.add(engine.world, ball);
            };

            const gameOver = () => {
                if (isGameOver.value) return;
                isGameOver.value = true;
                // åœæ­¢ç‰©ç†å¼•æ“
                render.options.enabled = false; 
            };

            const restart = () => {
                location.reload(); // ç®€å•ç²—æš´ï¼Œåˆ·æ–°é‡æ¥
            };

            // è·å–æ’è¡Œæ¦œ
            const loadRank = async () => {
                try {
                    const res = await fetch(`${API_BASE}/game/rank`);
                    rankList.value = await res.json();
                } catch(e) { console.error(e); }
            };

            // æäº¤åˆ†æ•°
            const submitScore = async () => {
                if (!playerName.value) return alert("è¯·è¾“å…¥åå­—å“¦");
                try {
                    await fetch(`${API_BASE}/game/submit`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            playerName: playerName.value,
                            score: currentScore.value
                        })
                    });
                    alert("æˆ˜ç»©å·²ä¸Šä¼ ï¼");
                    loadRank(); // åˆ·æ–°æ’è¡Œæ¦œ
                    showRank.value = true; // æ˜¾ç¤ºæ’è¡Œæ¦œ
                } catch(e) { alert("ç½‘ç»œé”™è¯¯"); }
            };

            onMounted(() => {
                initGame();
                loadRank();
            });

            return { 
                currentScore, isGameOver, playerName, 
                showRank, rankList,
                submitScore, restart 
            };
        }
    }).mount('#app');
</script>
</body>
</html>